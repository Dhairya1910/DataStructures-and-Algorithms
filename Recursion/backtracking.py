# -*- coding: utf-8 -*-
"""BackTracking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/154p4-bG9rHX-sbQoSFnFXFspHygFH0lj

# Knight's Tour Problem
**Same approch as graph in DFS or BFS**
"""

import numpy as np

grid = [[False] * 8 for _ in range(8)]
chess_board = [[-1] * 8 for _ in range(8)]

TOTAL_MOVES = 8 * 8

def goal_state(moves):
    return moves == TOTAL_MOVES

def valid_moves(row, col):
    return 0 <= row < 8 and 0 <= col < 8 and not grid[row][col]

def make_move(row, col, moves):
    if goal_state(moves):
        print("Solution Found! Here's the chessboard:")
        print(np.array(chess_board))
        return True


    knight_moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]

    for move in knight_moves:
        next_row = row + move[0]
        next_col = col + move[1]
            grid[next_row][next_col] = True  # Mark the square as visited
            chess_board[next_row][next_col] = moves  # Record the move

            # Recursively try the next move
            if make_move(next_row, next_col, moves + 1):
                return True  # If a solution is found, return True

            # Backtracking: undo the move
            grid[next_row][next_col] = False
            chess_board[next_row][next_col] = -1

    return False

grid[0][0] = True
chess_board[0][0] = 0


if not make_move(0, 0, 1):
    print("No solution exists for this starting position.")

print("Final grid state:")
print(np.array(grid))
print("Chessboard with move sequence:")
print(np.array(chess_board))

"""# Rat in a Maze Problem"""

# maze is the initial Matrix
import numpy as np
Maze = [[1,1,1,1],
        [1,0,0,1],
        [1,1,1,1],
        [0,0,0,1]
        ]
goal = (3,3)
Directions = "DLRU"
Solutions = []

def is_goal(tile):
  return tile == goal

def valid_move(row,col):
  return 0 <= row < 4 and 0 <= col < 4 and Maze[row][col] != 0 and Maze[row][col] != -1

def Move_mouse(row,col,path):
  if is_goal((row,col)):
    Solutions.append(path)
    print(np.array(Maze))
    return
  Moves = [(1,0),(0,1),(-1,0),(0,-1)]

  for i in range(len(Moves)):
    r , c = Moves[i]
    new_row = row + r
    new_col = col + c

    if valid_move(new_row,new_col):
      path = path + Directions[i]
      Maze[new_row][new_col] = -1
      Move_mouse(new_row,new_col,path)
      Maze[new_row][new_col] = 1
      path = ""

Maze[0][0] = -1
paths = ""
print(np.array(Move_mouse(0,0,paths)))

if Solutions:
  print(Solutions)
else:
  print("Not Found")

"""# N - Queens Problem
**Time for revenge**
"""

import numpy as np

Q = 4

def Valid_move(row,col,board):

  for i in range(col):
    if board[row][i] == 1 :
      return False

  for i,j in zip(range(row,-1,-1),range(col,-1,-1)):
    if board[i][j] == 1:
      return False

  for i,j in zip(range(row,Q,1),range(col,-1,-1)):
    if board[i][j] == 1:
      return False

  return True

def Make_move(board,col):

  if col >= Q :
    print(np.array(board))
    return True

  for row in range(N):

    if Valid_move(row,col,board):
      board[row][col] = 1
      Make_move(board,col+1)
      board[row][col] = 0

  return False


board = [[0,0,0,0],
         [0,0,0,0],
         [0,0,0,0],
         [0,0,0,0]
         ]

Make_move(board,0)

